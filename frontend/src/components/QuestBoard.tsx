'use client';

import { FC, useState, useEffect, useCallback } from 'react';
import Icon from './Icon';
import { useWriteContract, useWaitForTransactionReceipt } from 'wagmi';
import { CONTRACTS, publicClient, DEMO_MODE } from '@/lib/wagmi';
import { useDemoProgress } from '@/hooks/useDemoProgress';
import { DEMO_KEYS, loadDemo, saveDemo } from '@/lib/demo';

interface Quest {
    id: number;
    title: string;
    description: string;
    difficulty: 'Easy' | 'Medium' | 'Hard' | 'Epic';
    category: 'Social' | 'Technical' | 'Creative' | 'Community';
    reward: {
        experience: number;
        reputation: number;
        tokens?: number;
        achievement?: string;
    };
    requirements: string[];
    timeLimit?: string;
    participants: number;
    maxParticipants?: number;
    status: 'available' | 'active' | 'completed' | 'failed';
}

// Minimal QuestManager ABI for reads and completion
const QUEST_MANAGER_ABI = [
    {
        type: 'function',
        name: 'getQuestInfo',
        stateMutability: 'view',
        inputs: [{ name: 'questId', type: 'uint256' }],
        outputs: [
            { name: 'questType', type: 'uint8' },
            { name: 'difficulty', type: 'uint8' },
            { name: 'experienceReward', type: 'uint256' },
            { name: 'tokenReward', type: 'uint256' },
            { name: 'isActive', type: 'bool' },
            { name: 'completionCount', type: 'uint256' },
        ],
    },
    {
        type: 'function',
        name: 'questCounter',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: '', type: 'uint256' }],
    },
    {
        type: 'function',
        name: 'completeQuest',
        stateMutability: 'nonpayable',
        inputs: [
            { name: 'questId', type: 'uint256' },
            { name: 'proof', type: 'bytes' },
        ],
        outputs: [],
    },
] as const;

const QuestBoard: FC = () => {
    const [quests, setQuests] = useState<Quest[]>([]);
    const demoProgress = useDemoProgress();
    const [filter, setFilter] = useState<'all' | 'available' | 'active' | 'completed'>('all');
    const [categoryFilter, setCategoryFilter] = useState<'all' | Quest['category']>('all');
    const [isLoading, setIsLoading] = useState(true);
    const questManager = (CONTRACTS.questManager && CONTRACTS.questManager.startsWith('0x') && CONTRACTS.questManager.length === 42)
        ? (CONTRACTS.questManager as `0x${string}`)
        : undefined;
    const canUseOnchain = Boolean(questManager) && !DEMO_MODE;

    const loadQuests = useCallback(async () => {
        if (canUseOnchain) {
            try {
                // Get total quests and iterate
                const total = await publicClient.readContract({
                    address: questManager as `0x${string}`,
                    abi: QUEST_MANAGER_ABI,
                    functionName: 'questCounter',
                    args: [],
                });
                const count = Number(total || 0);
                const items: Quest[] = [];
                for (let i = 1; i <= count; i++) {
                    const info = await publicClient.readContract({
                        address: questManager as `0x${string}`,
                        abi: QUEST_MANAGER_ABI,
                        functionName: 'getQuestInfo',
                        args: [BigInt(i)],
                    });
                    if (!info) continue;
                    const [questType, difficulty, experienceReward, tokenReward, isActive, completionCount] = info as readonly [number, number, bigint, bigint, boolean, bigint];
                    items.push({
                        id: i,
                        title: ['Cipher Chamber', 'Elemental Forge', 'Shadow Duel', 'Memory Vault', 'Resource Rush'][Number(questType)] || `Quest #${i}`,
                        description: 'Onchain quest generated by QuestManager',
                        difficulty: ['Easy', 'Medium', 'Hard', 'Epic'][Number(difficulty)] as Quest['difficulty'],
                        category: ['Social', 'Creative', 'Technical', 'Community'][Number(questType) % 4] as Quest['category'],
                        reward: { experience: Number(experienceReward), reputation: 0, tokens: Number(tokenReward) / 1e18 },
                        requirements: ['Complete proof verification'],
                        participants: Number(completionCount),
                        status: isActive ? 'available' : 'completed',
                    });
                }
                setQuests(items);
                setIsLoading(false);
                return;
            } catch (e) {
                console.warn('Onchain quest load failed, falling back to mock', e);
            }
        }
        // Fallback mock if no onchain or in DEMO_MODE. Load from storage if present.
        const stored = loadDemo<Quest[]>(DEMO_KEYS.quests, []);
        const mockQuests: Quest[] = stored.length ? stored : [
            {
                id: 1,
                title: 'ENS Social Explorer',
                description: 'Follow 10 different ENS users and engage with their content',
                difficulty: 'Easy',
                category: 'Social',
                reward: { experience: 100, reputation: 20 },
                requirements: ['Have an ENS name', 'Connect to EFP protocol'],
                participants: 45,
                maxParticipants: 100,
                status: 'available'
            },
            {
                id: 2,
                title: 'Guild Founder',
                description: 'Create a new guild and recruit 5 members',
                difficulty: 'Hard',
                category: 'Community',
                reward: { experience: 500, reputation: 100, tokens: 1000, achievement: 'Guild Master' },
                requirements: ['Level 5+', '500+ reputation'],
                participants: 12,
                maxParticipants: 20,
                status: 'available'
            },
            {
                id: 3,
                title: 'Smart Contract Auditor',
                description: 'Review and verify a community-submitted smart contract',
                difficulty: 'Epic',
                category: 'Technical',
                reward: { experience: 1000, reputation: 200, tokens: 2000 },
                requirements: ['Technical Badge', 'Level 10+'],
                timeLimit: '7 days',
                participants: 3,
                maxParticipants: 5,
                status: 'available'
            },
            {
                id: 4,
                title: 'First Steps',
                description: 'Complete your character setup and make your first social connection',
                difficulty: 'Easy',
                category: 'Social',
                reward: { experience: 50, reputation: 10 },
                requirements: ['None'],
                participants: 1,
                status: 'active'
            }
        ];

        setQuests(mockQuests);
        saveDemo(DEMO_KEYS.quests, mockQuests);
        setIsLoading(false);
    }, [canUseOnchain, questManager]);

    useEffect(() => {
        loadQuests();
    }, [loadQuests]);

    const filteredQuests = quests.filter(quest => {
        if (filter !== 'all' && quest.status !== filter) return false;
        if (categoryFilter !== 'all' && quest.category !== categoryFilter) return false;
        return true;
    });

    const getDifficultyColor = (difficulty: Quest['difficulty']) => {
        switch (difficulty) {
            case 'Easy': return 'text-green-400 bg-green-900/30';
            case 'Medium': return 'text-yellow-400 bg-yellow-900/30';
            case 'Hard': return 'text-orange-400 bg-orange-900/30';
            case 'Epic': return 'text-purple-400 bg-purple-900/30';
        }
    };

    const getCategoryIcon = (category: Quest['category']) => {
        switch (category) {
            case 'Social': return <Icon name="users" size={20} />;
            case 'Technical': return <Icon name="code" size={20} />;
            case 'Creative': return <Icon name="paint" size={20} />;
            case 'Community': return <Icon name="community" size={20} />;
        }
    };

    const { writeContract, data: txHash } = useWriteContract();
    const { isLoading: confirming } = useWaitForTransactionReceipt({ hash: txHash });

    const handleCompleteQuest = async (questId: number) => {
        if (DEMO_MODE) {
            // Demo mode: mark quest completed and award XP using demo progress store
            let gained = 0;
            setQuests((prev) => {
                const updated: Quest[] = prev.map((q): Quest => {
                    if (q.id === questId && q.status !== 'completed') {
                        gained = q.reward.experience;
                        return { ...q, status: 'completed', participants: (q.participants || 0) + 1 };
                    }
                    return q;
                });
                saveDemo(DEMO_KEYS.quests, updated);
                return updated;
            });
            if (gained > 0) {
                demoProgress.addExperience(gained);
            }
            return;
        }
        if (!questManager) return;
        writeContract({
            address: questManager,
            abi: QUEST_MANAGER_ABI,
            functionName: 'completeQuest',
            args: [BigInt(questId), '0x'],
        });
    };

    if (isLoading) {
        return (
            <div className="flex justify-center items-center h-64">
                <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-400"></div>
            </div>
        );
    }

    return (
        <div className="space-y-6">
            {/* Header */}
            <div className="game-card p-6">
                <h2 className="text-2xl font-bold mb-4">Quest Board</h2>
                <p className="text-gray-400 mb-6">Accept quests to earn experience, reputation, and rewards</p>

                {/* Filters */}
                <div className="flex flex-wrap gap-4">
                    <div className="flex space-x-2">
                        <span className="text-sm text-gray-400">Status:</span>
                        {['all', 'available', 'active', 'completed'].map((status) => (
                            <button
                                key={status}
                                onClick={() => setFilter(status as 'all' | 'available' | 'active' | 'completed')}
                                className={`
                  px-3 py-1 text-xs rounded-full transition-colors capitalize
                  ${filter === status
                                        ? 'bg-blue-600 text-white'
                                        : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                                    }
                `}
                            >
                                {status}
                            </button>
                        ))}
                    </div>

                    <div className="flex space-x-2">
                        <span className="text-sm text-gray-400">Category:</span>
                        {['all', 'Social', 'Technical', 'Creative', 'Community'].map((category) => (
                            <button
                                key={category}
                                onClick={() => setCategoryFilter(category as 'all' | Quest['category'])}
                                className={`
                  px-3 py-1 text-xs rounded-full transition-colors
                  ${categoryFilter === category
                                        ? 'bg-purple-600 text-white'
                                        : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                                    }
                `}
                            >
                                {category}
                            </button>
                        ))}
                    </div>
                </div>
            </div>

            {/* Quest List */}
            <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                {filteredQuests.map((quest) => (
                    <div key={quest.id} className={`game-card p-6 ${quest.status === 'active' ? 'quest-active' : ''}`}>
                        <div className="flex justify-between items-start mb-3">
                            <div className="flex items-center space-x-2">
                                <span className="text-xl flex items-center">{getCategoryIcon(quest.category)}</span>
                                <h3 className="text-lg font-bold">{quest.title}</h3>
                            </div>
                            <div className="flex space-x-2">
                                <span className={`px-2 py-1 text-xs rounded-full ${getDifficultyColor(quest.difficulty)}`}>
                                    {quest.difficulty}
                                </span>
                                <span className={`
                  px-2 py-1 text-xs rounded-full capitalize
                  ${quest.status === 'available' ? 'bg-green-900/30 text-green-400' : ''}
                  ${quest.status === 'active' ? 'bg-orange-900/30 text-orange-400' : ''}
                  ${quest.status === 'completed' ? 'bg-blue-900/30 text-blue-400' : ''}
                `}>
                                    {quest.status}
                                </span>
                            </div>
                        </div>

                        <p className="text-gray-300 mb-4">{quest.description}</p>

                        {/* Requirements */}
                        <div className="mb-4">
                            <p className="text-sm text-gray-400 mb-2">Requirements:</p>
                            <div className="flex flex-wrap gap-1">
                                {quest.requirements.map((req, index) => (
                                    <span key={index} className="text-xs bg-gray-700 px-2 py-1 rounded">
                                        {req}
                                    </span>
                                ))}
                            </div>
                        </div>

                        {/* Rewards */}
                        <div className="mb-4 p-3 bg-gray-800 rounded-lg">
                            <p className="text-sm text-gray-400 mb-2">Rewards:</p>
                            <div className="flex flex-wrap gap-2 text-sm">
                                <span className="text-yellow-400">+{quest.reward.experience} XP</span>
                                <span className="text-purple-400">+{quest.reward.reputation} Rep</span>
                                {quest.reward.tokens && (
                                    <span className="text-green-400">+{quest.reward.tokens} QT</span>
                                )}
                                {quest.reward.achievement && (
                                    <span className="text-orange-400 inline-flex items-center gap-1"><Icon name="achievement" size={14} /> {quest.reward.achievement}</span>
                                )}
                            </div>
                        </div>

                        {/* Participants & Actions */}
                        <div className="flex justify-between items-center">
                            <div className="text-sm text-gray-400">
                                {quest.maxParticipants ? (
                                    <span>{quest.participants}/{quest.maxParticipants} participants</span>
                                ) : (
                                    <span>{quest.participants} participants</span>
                                )}
                                {quest.timeLimit && (
                                    <span className="ml-4 inline-flex items-center gap-1"><Icon name="clock" size={14} /> {quest.timeLimit}</span>
                                )}
                            </div>

                            <div className="flex space-x-2">
                                {quest.status !== 'completed' && (
                                    <button
                                        onClick={() => handleCompleteQuest(quest.id)}
                                        className={`px-4 py-2 text-sm rounded-lg ${confirming ? 'bg-gray-600 text-gray-400' : 'btn-secondary'}`}
                                        disabled={confirming}
                                    >
                                        {confirming ? 'Submitting...' : 'Complete'}
                                    </button>
                                )}
                                {quest.status === 'completed' && (
                                    <span className="px-4 py-2 text-sm text-green-400 inline-flex items-center gap-1"><Icon name="achievement" size={16} /> Completed</span>
                                )}
                            </div>
                        </div>
                    </div>
                ))}
            </div>

            {filteredQuests.length === 0 && (
                <div className="text-center py-12">
                    <div className="text-6xl mb-4 text-gray-600"><Icon name="dashboard" size={56} /></div>
                    <p className="text-lg text-gray-400">No quests found matching your filters</p>
                    <button
                        onClick={() => { setFilter('all'); setCategoryFilter('all'); }}
                        className="btn-primary mt-4"
                    >
                        Clear Filters
                    </button>
                </div>
            )}
        </div>
    );
};

export default QuestBoard;
